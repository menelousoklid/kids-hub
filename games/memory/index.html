<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#111111" />
  <title>√áocuklar ƒ∞√ßin E≈üle≈ütirme Oyunu</title>
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171a2b;
      --card:#1f2340;
      --card2:#232850;
      --text:#f2f5ff;
      --muted:#aab3d6;
      --good:#35d07f;
      --bad:#ff5b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --gap: 10px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 900px at 20% 10%, #1a1f43 0%, var(--bg) 55%, #0b0d18 100%);
      color:var(--text);
      overflow:hidden; /* mobilde kaydƒ±rmayƒ± kapat */
      touch-action: manipulation; /* gereksiz zoom/scrollu azalt */
      -webkit-tap-highlight-color: transparent;
    }

    /* App Shell */
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    header{
      padding:14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .title{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .logo{
      width:42px; height:42px;
      border-radius:14px;
      background: linear-gradient(135deg, #ffcc66, #ff6bd6 45%, #6b8bff);
      box-shadow: var(--shadow);
      display:grid;
      place-items:center;
      font-size:22px;
    }
    h1{
      margin:0;
      font-size:16px;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .sub{
      margin:2px 0 0;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .top-actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      border-radius: 999px;
      padding:10px 12px;
      font-size:13px;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
      box-shadow: 0 10px 20px rgba(0,0,0,.15);
    }
    .pill strong{ font-weight:800; }
    .btn{
      appearance:none;
      border:0;
      cursor:pointer;
      border-radius: 999px;
      padding:10px 14px;
      font-weight:800;
      font-size:13px;
      color:var(--text);
      background: linear-gradient(135deg, #6b8bff, #42e2ff);
      box-shadow: var(--shadow);
      user-select:none;
    }
    .btn:active{ transform: translateY(1px) scale(0.99); }
    .btn.secondary{
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
      box-shadow: 0 10px 22px rgba(0,0,0,.20);
    }

    main{
      flex:1;
      display:flex;
      padding: 6px 14px 14px;
      min-height:0;
    }
    .board-wrap{
      width:100%;
      max-width: 860px;
      margin: 0 auto;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    /* Difficulty bar */
    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 8px 8px 12px;
      flex-wrap:wrap;
    }
    .seg{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 999px;
      font-weight:800;
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .chip[aria-pressed="true"]{
      background: linear-gradient(135deg, #ffcc66, #ff6bd6);
      border-color: rgba(255,255,255,.22);
    }
    .hint{
      color: var(--muted);
      font-size:12px;
    }

    /* Grid */
    .grid{
      flex:1;
      display:grid;
      gap: var(--gap);
      align-content:center;
      justify-content:center;
      padding: 6px;
      min-height:0;
      /* mobile friendly: card size will adjust with JS vars */
      grid-template-columns: repeat(var(--cols, 4), minmax(0, 1fr));
      width: 100%;
    }

    /* Card */
    .card{
      position:relative;
      width: var(--cardSize, 76px);
      height: var(--cardSize, 76px);
      border-radius: 16px;
      perspective: 900px;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }
    .card button{
      all:unset;
      width:100%;
      height:100%;
      cursor:pointer;
      border-radius: 16px;
      outline:none;
      display:block;
    }

    .inner{
      width:100%;
      height:100%;
      position:relative;
      transform-style: preserve-3d;
      transition: transform .35s cubic-bezier(.2,.75,.2,1);
      border-radius: 16px;
    }
    .card.is-flipped .inner{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      border-radius: 16px;
      display:grid;
      place-items:center;
      backface-visibility:hidden;
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.12);
    }
    .front{
      background: linear-gradient(145deg, var(--card), var(--card2));
    }
    .front .qmark{
      font-size: 30px;
      filter: drop-shadow(0 8px 12px rgba(0,0,0,.25));
    }
    .back{
      transform: rotateY(180deg);
      background: rgba(255,255,255,.10);
    }
    .emoji{
      font-size: clamp(26px, 5vw, 40px);
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.25));
    }

    .card.is-matched .face{
      border-color: rgba(53, 208, 127, .55);
      box-shadow: 0 10px 28px rgba(53, 208, 127, .18);
    }
    .card.is-disabled{ pointer-events:none; opacity:.92; }
    .card.shake .inner{
      animation: shake .35s ease-in-out;
    }
    @keyframes shake{
      0%,100%{ transform: rotateY(180deg) translateX(0); }
      25%{ transform: rotateY(180deg) translateX(-6px); }
      75%{ transform: rotateY(180deg) translateX(6px); }
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      bottom: calc(18px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      background: rgba(0,0,0,.6);
      border:1px solid rgba(255,255,255,.18);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight:800;
      font-size:13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      max-width: calc(100% - 24px);
      text-align:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }

    /* Modal */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(520px, 100%);
      border-radius: 22px;
      background: rgba(23,26,43,.95);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .modal h2{ margin: 6px 0 6px; font-size:18px; }
    .modal p{ margin: 0 0 12px; color: var(--muted); }
    .modal .row{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }

    /* Small screens: make header compact */
    @media (max-width: 420px){
      header{ padding:12px 12px 8px; }
      main{ padding: 4px 12px 12px; }
      .pill{ padding:9px 10px; font-size:12px; }
      .btn{ padding:10px 12px; }
      .logo{ width:40px; height:40px; }
      h1{ font-size:15px; }
    }

    /* Reduce motion accessibility */
    @media (prefers-reduced-motion: reduce){
      .inner, .toast{ transition:none; }
      .card.shake .inner{ animation:none; }
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <header>
      <div class="title">
        <div class="logo" aria-hidden="true">üß†</div>
        <div style="min-width:0;">
          <h1>E≈üle≈ütirme Oyunu</h1>
          <div class="sub" id="subtitle">Kartlarƒ± e≈üle≈ütir, hepsini bul!</div>
        </div>
      </div>

      <div class="top-actions">
        <div class="pill" title="Hamle">
          üñ±Ô∏è Hamle: <strong id="moves">0</strong>
        </div>
        <div class="pill" title="S√ºre">
          ‚è±Ô∏è S√ºre: <strong id="time">00:00</strong>
        </div>
        <button class="btn secondary" id="btnBack" type="button" title="Men√ºye D√∂n">‚¨ÖÔ∏è Men√º
        </button>
        <button class="btn secondary" id="btnSound" type="button" aria-pressed="true" title="Ses">
          üîä Ses
        </button>
        <button class="btn" id="btnNew" type="button" title="Yeni Oyun">
          üîÅ Yeni
        </button>
      </div>
    </header>

    <main>
      <section class="board-wrap" aria-label="E≈üle≈ütirme oyunu alanƒ±">
        <div class="bar">
          <div class="seg" aria-label="Zorluk se√ßimi">
            <button class="chip" data-level="easy" aria-pressed="true" type="button">Kolay (2√ó2)</button>
            <button class="chip" data-level="medium" aria-pressed="false" type="button">Orta (4√ó3)</button>
            <button class="chip" data-level="hard" aria-pressed="false" type="button">Zor (4√ó4)</button>
          </div>
          <div class="hint" id="hint">ƒ∞pucu: √ñnce k√∂≈üeleri dene üôÇ</div>
        </div>

        <div class="grid" id="grid" role="grid" aria-label="Kart ƒ±zgarasƒ±"></div>
      </section>
    </main>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Oyun bitti">
    <div class="modal">
      <h2 id="winTitle">üéâ Tebrikler!</h2>
      <p id="winText">Hepsini buldun!</p>
      <div class="row">
        <button class="btn secondary" id="btnClose" type="button">Kapat</button>
        <button class="btn" id="btnAgain" type="button">Tekrar Oyna</button>
      </div>
    </div>
  </div>

  <script>
    // ============================
    // Kids-friendly Memory Game
    // - Big tap targets
    // - No scrolling/zooming
    // - Simple positive feedback
    // ============================
const btnBack = document.getElementById('btnBack');
btnBack.addEventListener('click', () => {
  window.location.href = "../../index.html";
});

    const gridEl = document.getElementById('grid');
    const movesEl = document.getElementById('moves');
    const timeEl  = document.getElementById('time');
    const toastEl = document.getElementById('toast');
    const overlay = document.getElementById('overlay');
    const winText = document.getElementById('winText');

    const btnNew   = document.getElementById('btnNew');
    const btnAgain = document.getElementById('btnAgain');
    const btnClose = document.getElementById('btnClose');
    const btnSound = document.getElementById('btnSound');

    const chips = [...document.querySelectorAll('.chip')];

    const LEVELS = {
      easy:   { cols: 2, rows: 2 }, // 4 cards (2 pairs)
      medium: { cols: 4, rows: 3 }, // 12 cards (6 pairs)
      hard:   { cols: 4, rows: 4 }  // 16 cards (8 pairs)
    };

    // Emoji sets (kid-safe)
    const EMOJIS = [
      "üê∂","üê±","üêº","ü¶ä","üê∏","üêµ","üê∞","ü¶Å",
      "üêØ","üê®","ü¶Ñ","üêô","üê§","üê¢","üê≥","ü¶ã",
      "üçé","üçå","üçì","üçâ","üçá","üçí","üçç","ü•ï",
      "üöó","üöï","üöí","üöë","üöú","üö≤","‚úàÔ∏è","üöÄ",
      "‚≠ê","üåô","‚òÄÔ∏è","üåà","‚ùÑÔ∏è","üçÄ","üéà","üéÅ"
    ];

    // State
    let levelKey = 'easy';
    let deck = [];
    let firstPick = null;
    let secondPick = null;
    let lock = false;
    let moves = 0;
    let matchedCount = 0;
    let timer = null;
    let seconds = 0;
    let soundOn = true;

    // Simple WebAudio feedback (no external files)
    let audioCtx = null;
    function beep(type){
      if(!soundOn) return;
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        const now = audioCtx.currentTime;
        const freq = type === "good" ? 740 : type === "win" ? 880 : 220;
        o.frequency.setValueAtTime(freq, now);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(now);
        o.stop(now + 0.20);
      }catch(e){
        // ignore
      }
    }

    // Prevent double-tap zoom on some browsers (still respects accessibility)
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove('show'), 1400);
    }

    function pad2(n){ return String(n).padStart(2,'0'); }
    function renderTime(){
      const m = Math.floor(seconds/60);
      const s = seconds%60;
      timeEl.textContent = `${pad2(m)}:${pad2(s)}`;
    }

    function startTimer(){
      stopTimer();
      seconds = 0;
      renderTime();
      timer = setInterval(() => {
        seconds++;
        renderTime();
      }, 1000);
    }
    function stopTimer(){
      if(timer){ clearInterval(timer); timer = null; }
    }

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildDeck(){
      const {cols, rows} = LEVELS[levelKey];
      const total = cols * rows;
      const pairs = total / 2;

      const picked = shuffle([...EMOJIS]).slice(0, pairs);
      const cards = shuffle([...picked, ...picked]).map((emoji, idx) => ({
        id: idx,
        emoji,
        matched: false
      }));

      return { cards, cols, rows, total, pairs };
    }

    function calcCardSize(cols, rows){
      // Make cards fit inside board on different screens.
      // We'll use viewport minus header-ish space, then compute a safe size.
      const vw = Math.min(window.innerWidth, 860);
      const vh = window.innerHeight;

      // board padding & UI approx
      const horizontalPadding = 14*2 + 12*2 + 16; // page + board + some
      const verticalReserved  = 170; // header + bar approx (works well)

      const usableW = Math.max(240, vw - horizontalPadding);
      const usableH = Math.max(240, vh - verticalReserved);

      const gap = 10; // matches --gap
      const sizeByW = Math.floor((usableW - gap*(cols-1)) / cols);
      const sizeByH = Math.floor((usableH - gap*(rows-1)) / rows);

      // clamp to kid-friendly tap sizes
      const size = Math.max(64, Math.min(110, Math.min(sizeByW, sizeByH)));
      return size;
    }

    function setGridVars(cols, rows){
      const size = calcCardSize(cols, rows);
      gridEl.style.setProperty('--cols', cols);
      gridEl.style.setProperty('--cardSize', size + 'px');
      // Slightly adapt gap for tiny screens
      const gap = size < 72 ? 8 : 10;
      gridEl.style.setProperty('--gap', gap + 'px');
    }

    function resetState(){
      firstPick = null;
      secondPick = null;
      lock = false;
      moves = 0;
      matchedCount = 0;
      movesEl.textContent = '0';
      stopTimer();
      seconds = 0;
      renderTime();
    }

    function createCardElement(card){
      const wrap = document.createElement('div');
      wrap.className = 'card';
      wrap.dataset.id = card.id;
      wrap.setAttribute('role','gridcell');

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.setAttribute('aria-label', 'Kart');

      const inner = document.createElement('div');
      inner.className = 'inner';

      const front = document.createElement('div');
      front.className = 'face front';
      const qm = document.createElement('div');
      qm.className = 'qmark';
      qm.textContent = '‚ùì';
      front.appendChild(qm);

      const back = document.createElement('div');
      back.className = 'face back';
      const em = document.createElement('div');
      em.className = 'emoji';
      em.textContent = card.emoji;
      back.appendChild(em);

      inner.appendChild(front);
      inner.appendChild(back);
      btn.appendChild(inner);
      wrap.appendChild(btn);

      btn.addEventListener('click', () => onCardTap(wrap), { passive: true });
      return wrap;
    }

    function renderBoard(){
      const { cards, cols, rows } = buildDeck();
      deck = cards;

      setGridVars(cols, rows);
      gridEl.innerHTML = '';
      const frag = document.createDocumentFragment();
      deck.forEach(c => frag.appendChild(createCardElement(c)));
      gridEl.appendChild(frag);

      // quick "preview" for kids: show all for a moment on harder levels
      if(levelKey !== 'easy'){
        lock = true;
        flipAll(true);
        setTimeout(() => {
          flipAll(false);
          lock = false;
          startTimer();
          showToast('Hazƒ±r mƒ±sƒ±n? Ba≈üla!');
        }, 1100);
      } else {
        startTimer();
        showToast('Ba≈üla! Kartlarƒ± e≈üle≈ütir üòä');
      }
    }

    function flipAll(show){
      const cards = gridEl.querySelectorAll('.card');
      cards.forEach(el => {
        if(show) el.classList.add('is-flipped');
        else el.classList.remove('is-flipped');
      });
    }

    function getCardDataByEl(cardEl){
      const id = Number(cardEl.dataset.id);
      return deck[id];
    }

    function onCardTap(cardEl){
      if(lock) return;

      const data = getCardDataByEl(cardEl);
      if(!data || data.matched) return;

      // prevent selecting same card twice
      if(firstPick && firstPick.el === cardEl) return;

      // Flip
      cardEl.classList.add('is-flipped');

      if(!firstPick){
        firstPick = { el: cardEl, data };
        beep("tap");
        return;
      }

      secondPick = { el: cardEl, data };
      lock = true;

      moves++;
      movesEl.textContent = String(moves);

      // Compare
      if(firstPick.data.emoji === secondPick.data.emoji){
        // Match!
        firstPick.data.matched = true;
        secondPick.data.matched = true;

        firstPick.el.classList.add('is-matched','is-disabled');
        secondPick.el.classList.add('is-matched','is-disabled');

        matchedCount += 2;
        beep("good");
        showToast('‚úÖ S√ºper!');

        clearPickAfter(320, () => {
          lock = false;
          checkWin();
        });
      } else {
        // Not match
        beep("bad");
        firstPick.el.classList.add('shake');
        secondPick.el.classList.add('shake');
        showToast('‚ùå Tekrar dene');

        setTimeout(() => {
          firstPick.el.classList.remove('shake');
          secondPick.el.classList.remove('shake');
          firstPick.el.classList.remove('is-flipped');
          secondPick.el.classList.remove('is-flipped');
          clearPick();
          lock = false;
        }, 720);
      }
    }

    function clearPick(){
      firstPick = null;
      secondPick = null;
    }

    function clearPickAfter(ms, cb){
      setTimeout(() => {
        clearPick();
        cb && cb();
      }, ms);
    }

    function checkWin(){
      const total = LEVELS[levelKey].cols * LEVELS[levelKey].rows;
      if(matchedCount >= total){
        stopTimer();
        beep("win");
        const mins = Math.floor(seconds/60);
        const secs = seconds%60;
        winText.textContent = `Hamle: ${moves} ‚Ä¢ S√ºre: ${pad2(mins)}:${pad2(secs)}`;
        overlay.classList.add('show');
      }
    }

    function setLevel(newLevel){
      levelKey = newLevel;
      chips.forEach(ch => ch.setAttribute('aria-pressed', String(ch.dataset.level === newLevel)));
      resetState();
      overlay.classList.remove('show');
      renderBoard();
    }

    function newGame(){
      resetState();
      overlay.classList.remove('show');
      renderBoard();
    }

    // Events
    chips.forEach(ch => {
      ch.addEventListener('click', () => setLevel(ch.dataset.level), { passive: true });
    });

    btnNew.addEventListener('click', newGame);
    btnAgain.addEventListener('click', newGame);
    btnClose.addEventListener('click', () => overlay.classList.remove('show'));

    btnSound.addEventListener('click', async () => {
      soundOn = !soundOn;
      btnSound.setAttribute('aria-pressed', String(soundOn));
      btnSound.textContent = soundOn ? 'üîä Ses' : 'üîá Ses';
      if(soundOn){
        // unlock audio on first user gesture
        try{
          if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          if(audioCtx.state === 'suspended') await audioCtx.resume();
          beep("good");
          showToast('Ses a√ßƒ±k');
        }catch(e){}
      }else{
        showToast('Ses kapalƒ±');
      }
    });

    // Recalculate card sizes on resize / orientation change
    window.addEventListener('resize', () => {
      const { cols, rows } = LEVELS[levelKey];
      setGridVars(cols, rows);
    });

    // Start
    setLevel('easy');
  </script>
</body>
</html>
